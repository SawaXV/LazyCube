Index: main/java/com/logic/CubeValidator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.logic;\n\nimport java.util.*;\nimport java.util.function.Predicate;\n\n/**\n * @author Alexander Bull\n * @editor Sarwar Rashid, Alfie Inman, Alfred Roberts\n * @description Responsible for validating a correct cube coniguration\n */\npublic class CubeValidator {\n    private final Cube cube;\n    private final int[] corners = {0, 2, 6, 8, 18, 20, 24, 26};\n    private final int[][] otherCorners = {{29, 36}, {9, 42}, {51, 35}, {15, 45}, {11, 44}, {27, 38}, {17, 47}, {33, 53}};\n\n    /**\n     * Pass a specified cube to enact as the cube being validated\n     * @param cube - Parameter cube to become the class' cube\n     */\n    public CubeValidator(Cube cube)\n    {\n        this.cube = cube;\n    }\n\n    /**\n     * Calls all four validation methods for a cube configuration\n     * @return Boolean value from any of the methods, true if correct configuration, false otherwise\n     */\n    public boolean isCubeValid()\n    {\n        return centresAreValid() && edgesAreValid() && cornersAreValid() && duplicateCorners() && countsAreValid();\n    }\n\n    /**\n     * Checks whether the centre of a cube is of a valid colour\n     * @return Returns true if valid, false otherwise\n     */\n    public boolean centresAreValid()\n    {\n        if(cube.getLongArray().get(4).getColour()!=CubeColour.ORANGE) return false;\n        if(cube.getLongArray().get(13).getColour()!=CubeColour.GREEN) return false;\n        if(cube.getLongArray().get(22).getColour()!=CubeColour.RED) return false;\n        if(cube.getLongArray().get(31).getColour()!=CubeColour.BLUE) return false;\n        if(cube.getLongArray().get(40).getColour()!=CubeColour.WHITE) return false;\n        return cube.getLongArray().get(49).getColour() == CubeColour.YELLOW;\n    }\n\n    /**\n     * Contains a valid set of edge pairs\n     */\n    private static class EdgePair\n    {\n        public CubeColour colOne;\n        public CubeColour colTwo;\n\n        public EdgePair(CubeColour colOne, CubeColour colTwo) {\n            this.colOne = colOne;\n            this.colTwo = colTwo;\n        }\n\n        @Override\n        public boolean equals(Object object)\n        {\n            if (object == this) {\n                return true;\n            }\n\n            if (!(object instanceof EdgePair)) {\n                return false;\n            }\n\n            EdgePair instance = (EdgePair) object;\n\n            if (instance.colOne != colOne && instance.colTwo != colTwo)\n            {\n                return true;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the edges of a cube is valid\n     * @param faces - A given face of the cube\n     * @return True if valid edges, false otherwise\n     */\n    public boolean edgesValid(int[] faces) {\n        List<EdgePair> pairs = new ArrayList<>();\n        EdgePair loopPair;\n        boolean valid = true;\n        int[][] locations = {{1, 39}, {3, 32}, {7, 48}, {5, 12}, {19, 41}, {21, 14}, {23, 30}, {25, 50}, {37, 28}, {34, 52}, {46, 16}, {10, 43}};\n\n        //this will loop through all the pairs of location in the array \"locations\"\n        for(int i = 0; i <= 11; i++)\n        {\n            int edgeIndex0 = locations[i][0];\n            int edgeIndex1 = locations[i][1];\n\n            // Get which face the edge is on\n            int edgeFace0 = edgeIndex0 / 9;\n            int edgeFace1 = edgeIndex1 / 9;\n\n            // Skip pairs in faces that aren't specified in the faces parameter\n            // TODO optimise this... only ever one edge between faces\n            if (Arrays.stream(faces).noneMatch(value -> value == edgeFace0)\n                    || Arrays.stream(faces).noneMatch(value -> value == edgeFace1))\n                continue;\n            if (cube.getLongArray().get(edgeIndex0).getColour() == CubeColour.NULL\n                    || cube.getLongArray().get(edgeIndex1).getColour() == CubeColour.NULL)\n                continue;\n            loopPair = new EdgePair(cube.getLongArray().get(edgeIndex0).getColour(), cube.getLongArray().get(edgeIndex1).getColour());\n            if (pairs.contains(loopPair))\n            {\n                valid = false;\n            }\n            pairs.add(loopPair);\n        }\n        for(EdgePair pair : pairs)\n        {\n            if (pair.colOne == CubeColour.GREEN && pair.colTwo == CubeColour.BLUE) { valid = false; }\n            if (pair.colOne == CubeColour.WHITE && pair.colTwo == CubeColour.YELLOW) { valid = false; }\n            if (pair.colOne == CubeColour.ORANGE && pair.colTwo == CubeColour.RED) { valid = false; }\n            if (pair.colOne == CubeColour.BLUE && pair.colTwo == CubeColour.GREEN) { valid = false; }\n            if (pair.colOne == CubeColour.YELLOW && pair.colTwo == CubeColour.WHITE) { valid = false; }\n            if (pair.colOne == CubeColour.RED && pair.colTwo == CubeColour.ORANGE) { valid = false; }\n            if (pair.colOne == pair.colTwo) { valid = false; }\n        }\n        return valid;\n    }\n\n    public boolean edgesAreValid() {\n        return edgesValid(new int[]{0,1,2,3,4,5});\n    }\n\n    /**\n     * Checks for a valid corner configuration\n     * @param faces - A given face of the cube\n     * @return True if correct configuration, false otherwise\n     */\n    public boolean invalidCorners(int[] faces) {\n        ArrayList<Square> cubeArr = cube.getLongArray();\n\n        /* for each corner, check its respective corners for invalid colour */\n        for (int i = 0; i < 8; i++) {\n            // Get which face the edge is on\n            int cornerFace0 = corners[i] / 9;\n            int cornerFace1 = otherCorners[i][0] / 9;\n            int cornerFace2 = otherCorners[i][1] / 9;\n\n            /* TODO optimise this... */\n            // Skip if none of the specified faces are within the corner\n            if ((Arrays.stream(faces).noneMatch(value -> value == cornerFace0)\n                    && Arrays.stream(faces).noneMatch(value -> value == cornerFace1)\n                    && Arrays.stream(faces).noneMatch(value -> value == cornerFace2)))\n                continue;\n            CubeColour[] corner = new CubeColour[]{cubeArr.get(corners[i]).getColour(),\n                    cubeArr.get(otherCorners[i][0]).getColour(),\n                    cubeArr.get(otherCorners[i][1]).getColour()};\n            // Skip only if 3 nulls\n            if (Arrays.stream(corner).filter(colour -> colour == CubeColour.NULL).count() <= 1) {\n                if (corner.length != new HashSet(List.of(corner)).size()) {\n                    return false;\n                }\n            }\n            if (cubeArr.get(corners[i]).getColour() == CubeColour.ORANGE) { /* ORANGE */\n                if (cubeArr.get(otherCorners[i][0]).getColour() == CubeColour.RED || cubeArr.get(otherCorners[i][1]).getColour() == CubeColour.RED) {\n                    return false;\n                }\n            }\n            if (cubeArr.get(corners[i]).getColour() == CubeColour.GREEN) { /* GREEN */\n                if (cubeArr.get(otherCorners[i][0]).getColour() == CubeColour.BLUE || cubeArr.get(otherCorners[i][1]).getColour() == CubeColour.BLUE) {\n                    return false;\n                }\n            }\n            if (cubeArr.get(corners[i]).getColour() == CubeColour.RED) { /* RED */\n                if (cubeArr.get(otherCorners[i][0]).getColour() == CubeColour.ORANGE || cubeArr.get(otherCorners[i][1]).getColour() == CubeColour.ORANGE) {\n                    return false;\n                }\n            }\n            if (cubeArr.get(corners[i]).getColour() == CubeColour.BLUE) { /* BLUE */\n                if (cubeArr.get(otherCorners[i][0]).getColour() == CubeColour.GREEN || cubeArr.get(otherCorners[i][1]).getColour() == CubeColour.GREEN) {\n                    return false;\n                }\n            }\n            if (cubeArr.get(corners[i]).getColour() == CubeColour.WHITE) { /* WHITE */\n                if (cube.getLongArray().get(otherCorners[i][0]).getColour() == CubeColour.YELLOW || cubeArr.get(otherCorners[i][1]).getColour() == CubeColour.YELLOW) {\n                    return false;\n                }\n            }\n            if (cubeArr.get(corners[i]).getColour() == CubeColour.YELLOW) { /* YELLOW */\n                if (cubeArr.get(otherCorners[i][0]).getColour() == CubeColour.WHITE || cubeArr.get(otherCorners[i][1]).getColour() == CubeColour.WHITE) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Applies invalidCorners to a list of corners\n     * @return True if valid, false otherwise\n     */\n    public boolean cornersAreValid() {\n        return invalidCorners(new int[]{0,1,2,3,4,5});\n    }\n\n    /**\n     * Checks whether the corner of a cube is a duplicate\n     * @return True if no duplicates, false otherwise\n     */\n    public boolean duplicateCorners() {\n        ArrayList<Square> cubeArr = cube.getLongArray();\n\n        /* for each valid corner and its colours, check if they are duplicated*/\n        for (int i = 0; i < 7; i++) {\n            for (int j = i + 1; j < 8; j++) {\n                if (cube.getLongArray().get(corners[i]).getColour() == CubeColour.NULL\n                        || cube.getLongArray().get(otherCorners[i][0]).getColour() == CubeColour.NULL\n                        || cube.getLongArray().get(otherCorners[i][1]).getColour() == CubeColour.NULL)\n                    continue;\n                if (cubeArr.get(corners[i]).getColour() == cubeArr.get(corners[j]).getColour()\n                        && cubeArr.get(otherCorners[i][0]).getColour() == cubeArr.get(otherCorners[j][0]).getColour()\n                        && cubeArr.get(otherCorners[i][1]).getColour() == cubeArr.get(otherCorners[j][1]).getColour()) {\n                    return false;\n                }\n                if (cubeArr.get(corners[i]).getColour() == cubeArr.get(corners[j]).getColour()\n                        && cubeArr.get(otherCorners[i][0]).getColour() == cubeArr.get(otherCorners[j][1]).getColour()\n                        && cubeArr.get(otherCorners[i][1]).getColour() == cubeArr.get(otherCorners[j][0]).getColour()) {\n                    return false;\n                }\n                if (cubeArr.get(corners[i]).getColour() == cubeArr.get(otherCorners[j][0]).getColour()\n                        && cubeArr.get(otherCorners[i][0]).getColour() == cubeArr.get(corners[j]).getColour()\n                        && cubeArr.get(otherCorners[i][1]).getColour() == cubeArr.get(otherCorners[j][1]).getColour()) {\n                    return false;\n                }\n                if (cubeArr.get(corners[i]).getColour() == cubeArr.get(otherCorners[j][0]).getColour()\n                        && cubeArr.get(otherCorners[i][0]).getColour() == cubeArr.get(otherCorners[j][1]).getColour()\n                        && cubeArr.get(otherCorners[i][1]).getColour() == cubeArr.get(corners[j]).getColour()) {\n                    return false;\n                }\n                if (cubeArr.get(corners[i]).getColour() == cubeArr.get(otherCorners[j][1]).getColour()\n                        && cubeArr.get(otherCorners[i][0]).getColour() == cubeArr.get(corners[j]).getColour()\n                        && cubeArr.get(otherCorners[i][1]).getColour() == cubeArr.get(otherCorners[j][0]).getColour()) {\n                    return false;\n                }\n                if (cubeArr.get(corners[i]).getColour() == cubeArr.get(otherCorners[j][1]).getColour()\n                        && cubeArr.get(otherCorners[i][0]).getColour() == cubeArr.get(otherCorners[j][0]).getColour()\n                        && cubeArr.get(otherCorners[i][1]).getColour() == cubeArr.get(corners[j]).getColour()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n\n    }\n\n    public boolean countsAreValid()\n    {\n        int counts[] = new int[7];\n        int colour;\n\n        for (int i=0; i<54; i++)\n        {\n            colour = cube.getLongArray().get(i).getColour().ordinal();\n            counts[colour]++;\n            if(colour<6 && counts[colour]>9)\n                return false;\n        }\n\n        return true;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main/java/com/logic/CubeValidator.java b/main/java/com/logic/CubeValidator.java
--- a/main/java/com/logic/CubeValidator.java	(revision 9b41c676ef408e5322cede3b85a7dd344ad3cac6)
+++ b/main/java/com/logic/CubeValidator.java	(date 1676040324265)
@@ -270,4 +270,6 @@
         return true;
     }
 
+
+
 }
